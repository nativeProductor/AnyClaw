基于 OpenClaw 插件系统实现深度拆解 和源码研究，结合AnyClaw — 记忆系统设计中的五层记忆架构，设计AnyClaw的技能系统——让AnyClaw既有「经验脑」，也有「手和脚」，还能在工作中自我进化。
一、重新认识 OpenClaw 的 Skill
Skill 在 OpenClaw 中已经是一个完整的「知识 + 执行」单元，不是纯文本说明书。
一个 OpenClaw Skill 包（技能包）本质上是一个插件，通过 register(api) 注册，具备：
Skill 包
├── 知识部分：SKILL.md / prompt context
│   └── 注入到 Agent 的系统提示，告知「如何做」
│
├── 执行部分：register(api) 函数
│   ├── api.registerTool(...)     — 注册 LLM 可调用的工具
│   ├── api.registerHook(...)     — 注册生命周期钩子
│   └── api.registerService(...) — 注册后台服务
│
└── 清单：openclaw.plugin.json
    ├── id / name
    └── configSchema（必填）



因此，不需要引入「复合技能」这个新概念——Skill 本身已经同时拥有知识和执行力。
二、Skill 真正缺什么
在 OpenClaw 现有的 Skill 机制之上，AnyClaw平台缺少以下能力：
缺失能力
现状
我们要补充的
自省能力
任务完成后无结构化反思
Heartbeat 守护进程定时深度自省，沉淀经验
Skill 自生成
只有开发者能创建 Skill
Agent 在自省中发现高频模式 → 生成 Skill 草稿
生命周期管理
无状态机，只有「有」或「没有」
草稿 → 测试 → 待审核 → 上线 → 废弃
来源追踪
所有 Skill 来自开发者，无区分
标记：开发者创建 / 培训沉淀 / Agent 自省生成
经验沉淀
无使用统计和效果反馈
调用次数、成功率、失败归因写回 Skill 元数据

---
三、扩展 Skill 清单（Extended Manifest）
在 openclaw.plugin.json 原有字段之上，增加AnyClaw平台专属的扩展字段：
{
  // ── OpenClaw 原有字段（保持不变）──────────────────
  "id": "query-reimbursement-status",
  "name": "查询报销进度",
  "configSchema": { ... },

  // ── AnyClaw平台扩展字段 ─────────────────────────
  "dep": {
    "source": "reflection",          // developer | training | reflection
    "status": "pending_review",      // draft | testing | pending_review | live | deprecated
    "version": 3,
    "created_at": "2026-02-25T08:47:00Z",
    "promoted_at": null,

    "requires_permissions": ["oa_api.read"],
    "related_skills": ["submit-reimbursement", "overtime-approval"],

    "experience": {
      "call_count_7d": 142,
      "success_rate_7d": 0.96,
      "p95_latency_ms": 430,
      "top_failure": "工单号格式错误（占失败的 83%）"
    },

    "review": {
      "proposed_by": "reflection-report-2026-02-25-0847",
      "reviewed_by": null,
      "review_note": null
    }
  }
}



字段说明：
- source：来源标记，决定审核严格程度（开发者创建可直接上线，Agent 自省生成必须审核）
- status：生命周期状态，见第四章
- experience：运行时写入，7 天滚动窗口，不影响 Skill 本体逻辑
- review：自省生成的 Skill 专属，记录提案来源和审核结果

---
四、Skill 生命周期
4.1 状态机
          开发者创建
               │
               ▼
           [草稿 draft]
               │  开发者提交测试
               ▼
          [测试中 testing]  ◄── 沙箱自动回归测试
               │  测试通过
               ▼
       [待审核 pending_review]  ◄── Agent 自省生成的 Skill 进入此状态
               │  开发者审批
               ▼
           [上线 live]  ──► 写入 Skill 注册表，Agent 立即可用
               │  主动废弃 / 被新版本替代
               ▼
         [废弃 deprecated]



4.2 同类 Skill 的版本互斥
借鉴 OpenClaw 的 Memory Slot 互斥机制：同一个 id 的 Skill 同时只有一个 live 版本。新版本上线时，旧版本自动变为 deprecated。
function resolveSkillVersionConflict(skillId: string, incoming: SkillRecord) {
  const current = registry.skills.find(s => s.id === skillId && s.status === "live");
  if (current) {
    current.status = "deprecated";
    current.deprecated_at = new Date().toISOString();
  }
  incoming.status = "live";
  incoming.promoted_at = new Date().toISOString();
}




---
五、自省系统（Self-Reflection）
自省是技能系统进化的引擎：让AnyClaw结构化反思，识别高频模式，并将模式转化为新的 Skill 草稿。岗位对齐分（JAS）是自省系统的核心治理信号——它决定自省的产出能否被采纳，以及 Skill 能否被提案。
5.1 触发架构：钩子 + Heartbeat 守护进程
自省分为两个层次，相互解耦：
**轻量自省（task_complete 钩子，每次任务后）**不触发 LLM 推理，零成本：
- 记录任务结果（成功/失败）
- 记录工具调用序列和职责标签
- 提取步骤写入 Layer 5 程序性记忆
- 更新 Skill experience 统计
- 记录各层 Token 消耗明细（input_breakdown 按 L1-L5 分解，同步扫描 [CITE:XXXX] 标记统计 Layer 2 引用率）
**深度自省（Heartbeat 守护进程，定时运行）**独立于主 Agent 循环，Agent 睡眠时也持续运行：
- soul_reflection（默认每天 1 次）：分析 50 次工具调用 + 识别高频模式 + 计算岗位对齐分 + 执行 Skill 提案门控
- skill_experience_rollup（每天 1 次）：汇总 7 天统计，更新各 Skill manifest experience 块
- check_skill_updates（每小时）：检测开发者是否发布新 Skill 版本
5.2 新增的生命周期钩子
在 OpenClaw 原有 18 个钩子基础上，增加自省相关钩子：
钩子名
时机
执行模式
task_complete
任务结束后
并行 Void（不阻塞，仅数据写入）
reflection_start
深度自省开始
串行（收集上下文）
reflection_end
深度自省完成
串行（触发 Skill 生成）
skill_proposed
Skill 草稿生成
并行 Void（通知开发者）
skill_approved
审核通过
串行（写入注册表）
skill_activated
Skill 上线生效
并行 Void（通知 Agent 刷新）
skill_deprecated
Skill 被废弃
并行 Void（清理引用）
5.3 自省报告结构
深度自省（soul_reflection）产出结构化报告。岗位对齐评估是报告的核心节，不仅记录分数，还要输出完整归因，供开发者判断是否干预：
自省报告 #2026-02-25-0847
├── 任务概要
│   ├── 分析窗口：近 50 次工具调用（2026-02-18 ~ 2026-02-25）
│   ├── 任务成功率：94%（47/50）
│   └── 平均对话轮次：2.3
│
├── Skill 使用统计
│   ├── query-reimbursement-policy：调用 28 次，成功率 100%
│   ├── submit-reimbursement：调用 12 次，成功率 83%
│   └── query-approval-status：调用 10 次，成功率 90%
│
├── ━━━ 岗位对齐评估 ━━━
│   ├── 本次 JAS：0.82 ✅（上次：0.85，变化：-0.03，正常波动）
│   │
│   ├── Jaccard（范围精度）：0.89
│   │   ├── A_actual（实际能力集）：{报销查询, 政策解答, 工单引导, 进度查询}
│   │   ├── A_role（岗位定义集）：{报销查询, 政策解答, 工单引导, 进度查询, 异常上报}
│   │   └── 越界能力：无 ✅
│   │
│   ├── Recall（职责覆盖率）：0.92
│   │   ├── D_role（应覆盖职责）：{报销查询, 政策解答, 工单引导, 进度查询, 异常上报}
│   │   ├── D_actual（实际覆盖）：{报销查询, 政策解答, 工单引导, 进度查询}
│   │   └── 未覆盖职责：[异常上报]（本周期未触发，非结构性缺失）
│   │
│   └── 告警状态：无告警，JAS ≥ 0.8
│       门控决定：✅ 允许 Skill 提案生成
│
├── 模式发现
│   ├── 🔁 重复：本周 23 次「查报销标准」，每次都走经验库检索
│   └── 💡 建议：可以把「城市等级查询 + 职级差异计算」封装为工具
│
├── 能力缺口
│   └── ⚠️ 用户追问「超标怎么审批」，需再检索一次
│       建议在 query-reimbursement-policy 的 SKILL.md 中增加关联说明
│
└── Skill 提案（岗位对齐分通过门控，允许生成）
    └── 提案 #P-0058：新建 query-reimbursement-standard
        ├── 依据：success_count = 23，success_rate = 100%
        ├── 边界校验：所涉工具均在 A_role 范围内 ✅
        ├── source: reflection
        └── 知识部分：合并「报销标准查询」+「超标审批」
│
└── ━━━ 记忆成本快照（cost_awareness.observation = true 时始终采集）━━━
    ├── 本期平均单任务：input 3,800 tokens · output 380 tokens · ≈$0.017
    ├── Layer 2 检索效率：0.61 ⚠️（低于 0.65 健康线）
    │   ├── 本期注入：2,100 tokens（占 input 55%）
    │   ├── 实际引用：1,270 tokens（cited_rate 60%）
    │   └── 未引用候选僵尸：卡片 #0055（retrieved 12 次，cited 0）
    └── 相比上期：成本 +8%（原因：政策文档更新，卡片数量增加）




5.4 岗位对齐分对 Skill 提案的门控
对齐分是 Skill 从 Layer 5 晋升为正式提案的关键门控，行为成熟度（success_count）是必要条件，对齐合规是充分条件：
5.5 JAS 下降时对在线 Skill 的干预
岗位对齐分不仅影响新 Skill 的生成，也影响已上线 Skill 的运行：
JAS 范围
对在线 Skill 的干预
≥ 0.8
无干预，正常运行
[0.6, 0.8)
对 source: reflection 的 Skill 标记观察期，记录其调用是否与分数下降相关
[0.4, 0.6)
暂停新 Skill 提案；对观察期中的 reflection Skill 发出复核通知
< 0.4
暂停所有自省生成；强制复核所有 source: reflection 的 live Skill；必要时临时下线可疑 Skill
5.6 JAS 恢复与自动解锁
人工修复完成后（清除越界 L5 记录、下线越界 Skill），系统在下次 Heartbeat 运行时自动重新计算 JAS，恢复正常流程，无需手动解锁。
完整的 JAS 定义、公式推导、跨系统调控架构，见：AnyClaw — 岗位对齐度评估体系
六、Skill 自生成
6.1 Agent 生成的是什么
Agent 在自省中发现高频模式后，生成的是一个完整的 Skill 包草稿，结构与开发者手写的 Skill 完全一致：
skills/query-reimbursement-standard/  ← Agent 生成的草稿目录
├── openclaw.plugin.json              ← 含 source: "reflection" 标记
├── SKILL.md                          ← Agent 撰写的知识文档
├── index.ts                          ← register 函数（调用 registerTool 等）
└── src/
    └── tools.ts                      ← 工具实现代码



6.2 生成流程
自省报告识别高频模式
        │
        ▼
Agent 起草 Skill 包
├── 撰写 SKILL.md（操作步骤、注意事项）
├── 编写工具代码（封装重复操作）
└── 填写 manifest（标注 source: reflection）
        │
        ▼
SKILL.md 内容过注入防御扫描（见 6.4）
        │
        ▼
写入 draft 状态的草稿目录
        │
        ▼
触发 skill_proposed 钩子 → 通知开发者审核
        │
   ┌────┴────┐
   │         │
  审批       驳回（附原因）
   │
   ▼
沙箱回归测试通过
   │
   ▼
status → live，注册表热更新



6.3 工具代码的安全约束
Agent 生成的工具代码在严格受限的沙箱中运行。
约束
规则
原因
网络访问
仅白名单内部 API
防止数据外泄
文件系统
不可访问
隔离运行环境
执行时间
单次最长 30 秒
防止阻塞主流程
内存
单次最大 128MB
防止资源耗尽
代码复杂度
禁止 eval / 动态 import / 递归
代码可静态分析
第三方依赖
仅预置安全 SDK
供应链安全
6.4 SKILL.md 内容注入防御
工具代码有沙箱保护，但知识文本（SKILL.md）本身也有注入风险——恶意构造的 SKILL.md 可以影响 Agent 行为或绕过权限边界。按来源严格度分级扫描：
写入时机                 规则严格度
────────────────────────────────────────────────
Agent 自生成 SKILL.md   ★★★★★ 最严格（Agent 可能被误导生成）
外部 git 仓库安装 Skill  ★★★★★ 最严格（来源不可控）
开发者管理界面提交        ★★★☆☆ 较宽松（可信来源，只做基础检查）



扫描规则（按威胁等级）：
等级
检测项
响应
Critical
自毁指令 / 数据库删除 / 进程终止
拒绝写入 + 告警开发者
High
财务操纵指令 / System prompt 覆盖尝试
拒绝写入 + 告警开发者
Medium
Tool-call 语法嵌入 / ChatML 特殊 token
写入 pending_review 状态，不自动上线
Low
零宽字符 / 同形字符 / 超过 10,000 字符
日志记录，正常写入

---
七、开发者管理界面
Skill 工作台
- 按来源筛选：开发者创建 / 培训沉淀 / 自省生成
- 按状态筛选：草稿 / 测试中 / 待审核 / 已上线
- 查看经验统计：调用次数、成功率、P95 延迟
- 版本 diff 对比代码编辑器
- SKILL.md 可视化编辑
- 工具代码编辑器（语法高亮 + 静态检查）
- manifest 扩展字段表单
自省报告
- 按时间浏览所有自省报告
- 查看 Skill 提案及其来源
- 查看岗位对齐分趋势图
- 一键审批 / 驳回 / 加批注
- 统计：本周自省次数、提案数、采纳率沙箱测试
- 手动输入测试用例
- 自动回归测试（上线后定期运行）
- 执行日志与性能数据
- 安全扫描报告（含 SKILL.md 注入扫描结果）
自省行为配置
配置项
默认值
说明
轻量自省（task_complete）
开启
每次任务后纯数据写入，零 LLM 成本
深度自省频率（Heartbeat）
每天 1 次
soul_reflection 任务间隔
回顾任务窗口
近 50 次工具调用
深度反思的分析范围
自动生成 Skill 草稿
需审批
发现模式后是否自动起草 Skill
Skill 自动上线
关闭
测试通过后是否跳过人工审核
最大草稿 Skill 数
20
防止 Agent 过度生成
岗位对齐分告警阈值
0.6
低于此值向开发者发送告警
岗位对齐分暂停阈值
0.4
低于此值暂停 Skill 自生成

---
八、Skill 与五层记忆的关系
关键交互：
记忆层
与 Skill 系统的关系
Layer 1 岗位人设
决定 Agent 加载哪些 Skill（「财务专员」不加载「代码审查」Skill）；SHA-256 保护确保角色边界不被 Skill 生成过程篡改
Layer 2 工作经验
经验卡片是 SKILL.md 知识的来源；Skill 运行的经验统计也回写到经验库
Layer 3 用户记忆
影响 Skill 选择（「这个用户习惯简短回答」→ 优先调用精简版 Skill）
Layer 4 会话上下文
任务完成后的上下文是轻量自省的输入数据
Layer 5 程序性记忆
轻量自省的输出目标；success_count ≥ 10 时自动向 Skill 系统提交草稿

---
九、技术架构总结
与 OpenClaw 插件系统的对应关系
OpenClaw 组件
AnyClaw平台的适配
变化
Plugin Discovery（4 个扫描位置）
Skill Discovery（增加草稿目录扫描）
增加 skills/drafts/ 扫描位置
Plugin Manifest（id + configSchema）
Skill Manifest（原有字段 + dep 扩展块）
向后兼容，扩展不破坏原有 Skill
Plugin Loader（Jiti 动态加载）
Skill Loader（热加载 + Agent 生成代码沙箱执行）
Agent 生成的工具代码走独立沙箱
Plugin Registry（中央注册表）
Skill Registry（带生命周期状态过滤）
只有 live 状态的 Skill 对 Agent 可见
Tool Factory（上下文感知）
不变，直接复用
无变化
Hook Runner（18 个钩子点）
增加 7 个自省相关钩子
见第五章
Memory Slot 互斥
同 id 的 Skill 只允许一个 live 版本
复用互斥逻辑，应用于 Skill 版本
Graceful Degradation
不变，直接复用
单个 Skill 异常不影响整体

---
附录：参考资料
- OpenClaw 插件系统实现深度拆解（前置研究）
- OpenClaw 记忆系统深度分析（前置研究）
- AI Agent 记忆系统方案对比（2026）（前置研究）
- AnyClaw — 记忆系统设计（关联文档）
- Conway Research/automaton（Heartbeat 守护进程 / Genesis Alignment Score / SKILL.md 注入防御参考）

---
Changelog
版本
日期
变更内容
变更原因
v1.0
2026-02-25
初始版本，基于 OpenClaw 插件系统设计技能系统（发现问题：Skill 已有执行力，不需要「复合技能」新概念）
—
v1.1
2026-02-27
移除「复合技能」概念，回归 Skill 本体；设计 Extended Manifest、生命周期状态机、自省系统、Skill 自生成
设计前提修正：Skill 本身即「知识 + 执行」
v1.2
2026-02-27
自省触发架构拆分为「轻量钩子 + Heartbeat 守护进程」；自省报告新增岗位对齐分（JAS）及告警/暂停规则；Skill 自生成流程新增 SKILL.md 注入防御扫描层（6.4 节）；第八章更新为五层记忆关系
基于 Automaton (Conway Research) 调研
v1.3
2026-02-27
第五章自省系统全面扩展：完整 JAS 公式与归因细节（5.3）、Skill 提案双重门控流程图（5.4）、JAS 下降时在线 Skill 干预分级（5.5）、自动恢复机制（5.6）；关联岗位对齐度评估体系独立文档
设计评审：岗位对齐分是技能系统的核心治理信号，原设计仅在报告中简单提及，缺少完整的门控逻辑和干预机制
v1.4
2026-02-27
5.1 task_complete 钩子增加 per-layer Token 归因字段；5.3 自省报告增加「记忆成本快照」节（Layer 2 检索效率、成本趋势）；附录新增成本文档引用
成本思维设计评审：自省报告缺少成本维度，开发者无法感知 Token 消耗变化及 Layer 2 检索效率
